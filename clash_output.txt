[1 of 1] Compiling GAUSSIAN         ( guassian_blur.hs, guassian_blur.o )

guassian_blur.hs:190:20: error:
    Variable not in scope:
      withImagePtr :: Image -> (Ptr GDImage -> IO CInt) -> IO Color
    |
190 | getPixel (x,y) i = withImagePtr i f
    |                    ^^^^^^^^^^^^

guassian_blur.hs:191:38: error:
    • Variable not in scope: int :: Int -> CInt
    • Perhaps you meant ‘init’ (imported from Clash.Prelude)
    |
191 |     where f p' = gdImageGetPixel p' (int x) (int y)
    |                                      ^^^

guassian_blur.hs:191:46: error:
    • Variable not in scope: int :: Int -> CInt
    • Perhaps you meant ‘init’ (imported from Clash.Prelude)
    |
191 |     where f p' = gdImageGetPixel p' (int x) (int y)
    |                                              ^^^

guassian_blur.hs:199:6: error:
    • Variable not in scope: int :: Signed 8 -> Color
    • Perhaps you meant ‘init’ (imported from Clash.Prelude)
    |
199 |     (int a `F.shiftL` 24) .|.
    |      ^^^

guassian_blur.hs:200:6: error:
    • Variable not in scope: int :: Signed 8 -> Color
    • Perhaps you meant ‘init’ (imported from Clash.Prelude)
    |
200 |     (int r `F.shiftL` 16) .|.
    |      ^^^

guassian_blur.hs:201:6: error:
    • Variable not in scope: int :: Signed 8 -> Color
    • Perhaps you meant ‘init’ (imported from Clash.Prelude)
    |
201 |     (int g `F.shiftL` 8)  .|.
    |      ^^^

guassian_blur.hs:202:6: error:
    • Variable not in scope: int :: Signed 8 -> Color
    • Perhaps you meant ‘init’ (imported from Clash.Prelude)
    |
202 |      int b
    |      ^^^

guassian_blur.hs:216:5: error:
    Variable not in scope:
      withImagePtr
        :: Vec n3 (Vec n2 (Signed 8)) -> (Ptr GDImage -> IO ()) -> IO ()
    |
216 |     withImagePtr i $ \p ->
    |     ^^^^^^^^^^^^

guassian_blur.hs:217:28: error:
    • Data constructor not in scope:
        Signed :: Integer -> Signed 8 -> CInt
    • Perhaps you meant variable ‘isSigned’ (imported from Data.Bits)
    |
217 |         gdImageSetPixel p (Signed 8 x) (Signed 8 y) c
    |                            ^^^^^^

guassian_blur.hs:217:41: error:
    • Data constructor not in scope:
        Signed :: Integer -> Signed 8 -> CInt
    • Perhaps you meant variable ‘isSigned’ (imported from Data.Bits)
    |
217 |         gdImageSetPixel p (Signed 8 x) (Signed 8 y) c
    |                                         ^^^^^^

guassian_blur.hs:217:53: error:
    • Couldn't match type ‘Signed 8’ with ‘CInt’
      Expected type: CInt
        Actual type: Color
    • In the fourth argument of ‘gdImageSetPixel’, namely ‘c’
      In the expression: gdImageSetPixel p (Signed 8 x) (Signed 8 y) c
      In the second argument of ‘($)’, namely
        ‘\ p -> gdImageSetPixel p (Signed 8 x) (Signed 8 y) c’
    |
217 |         gdImageSetPixel p (Signed 8 x) (Signed 8 y) c
    |                                                     ^

guassian_blur.hs:221:5: error:
    • Couldn't match kind ‘Nat’ with ‘*’
      When matching types
        IO :: * -> *
        Signed :: Nat -> *
      Expected type: Signed 8
        Actual type: IO ()
    • In a stmt of a 'do' block:
        (nr, ng, nb, na) <- foldM
                              (\ (or, og, ob, oa) j
                                 -> do let yy = ...
                                       (pr, pg, pb, pa) <- foldM
                                                             (\ (ar, ag, ab, aa) k -> do ...)
                                                             (or, og, ob, oa)
                                                             [0 .. 255]
                                       return (pr, pg, pb, pa))
                              ((0.0, 0.0, 0.0, 0.0) :: (Signed 8, Signed 8, Signed 8, Signed 8))
                              [0 .. 255]
      In the expression:
        do (nr, ng, nb, na) <- foldM
                                 (\ (or, og, ob, oa) j
                                    -> do let ...
                                          ....)
                                 ((0.0, 0.0, 0.0, 0.0) :: (Signed 8, Signed 8, Signed 8, Signed 8))
                                 [0 .. 255]
           let new_r = clamp 0 255 . truncate $ (nr / fdiv) + offset
               new_g = clamp 0 255 . truncate $ (ng / fdiv) + offset
               ....
           setPixel (x, y) (rgba new_r new_g new_b (truncate na)) img
      In an equation for ‘convoluteImage’:
          convoluteImage img imgCpy matrix fdiv offset x y
            = do (nr, ng, nb, na) <- foldM
                                       (\ (or, og, ob, oa) j -> do ...)
                                       ((0.0, 0.0, 0.0, 0.0) ::
                                          (Signed 8, Signed 8, Signed 8, Signed 8))
                                       [0 .. 255]
                 let new_r = ...
                     ....
                 setPixel (x, y) (rgba new_r new_g new_b (truncate na)) img
    |
221 |     (nr,ng,nb,na) <- foldM (\(or,og,ob,oa) j -> do
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...

guassian_blur.hs:225:43: error:
    • Couldn't match expected type ‘Int’ with actual type ‘Signed 8’
    • In the expression: xx
      In the first argument of ‘getPixel’, namely ‘(xx, yy)’
      In a stmt of a 'do' block: curr <- getPixel (xx, yy) imgCpy
    |
225 |                         curr <- getPixel (xx,yy) imgCpy
    |                                           ^^

guassian_blur.hs:225:46: error:
    • Couldn't match expected type ‘Int’ with actual type ‘Signed 8’
    • In the expression: yy
      In the first argument of ‘getPixel’, namely ‘(xx, yy)’
      In a stmt of a 'do' block: curr <- getPixel (xx, yy) imgCpy
    |
225 |                         curr <- getPixel (xx,yy) imgCpy
    |                                              ^^

guassian_blur.hs:225:50: error:
    • Couldn't match expected type ‘Image’
                  with actual type ‘Vec n3 (Vec n2 (Signed 8))’
    • In the second argument of ‘getPixel’, namely ‘imgCpy’
      In a stmt of a 'do' block: curr <- getPixel (xx, yy) imgCpy
      In the expression:
        do let xx = min (max (x - (1 + k)) 0) (max (x - 1) 0)
           curr <- getPixel (xx, yy) imgCpy
           let (r, g, b, a) = toRGBA curr
           return
             (ar + fromIntegral r * ((matrix !! j) !! k), 
              ag + fromIntegral g * ((matrix !! j) !! k), 
              ab + fromIntegral b * ((matrix !! j) !! k), fromIntegral a)
    • Relevant bindings include
        matrix :: Vec n3 (Vec n2 (Signed 8))
          (bound at guassian_blur.hs:220:27)
        imgCpy :: Vec n3 (Vec n2 (Signed 8))
          (bound at guassian_blur.hs:220:20)
        img :: Vec n3 (Vec n2 (Signed 8))
          (bound at guassian_blur.hs:220:16)
        convoluteImage :: Vec n3 (Vec n2 (Signed 8))
                          -> Vec n3 (Vec n2 (Signed 8))
                          -> Vec n3 (Vec n2 (Signed 8))
                          -> Signed 8
                          -> Signed 8
                          -> Signed 8
                          -> Signed 8
                          -> Signed 8
          (bound at guassian_blur.hs:220:1)
    |
225 |                         curr <- getPixel (xx,yy) imgCpy
    |      